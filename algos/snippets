# Sets items as a collection
comboBox.setItems(EnumSet.allOf(Status.class));


List<String> listaProperties  = new ArrayList<String>(Arrays.asList("codice", "sigla", "descrizione"));
List<String> places = Arrays.asList("codice", "sigla", "descrizione");
List<String> places = Collections.singletonList("codice");

# @Autowired interno alle Enumeration
//    @Component
//    public static class MeseServiceInjector {
//
//        @Autowired
//        private ATextService text;
//
//
//        @PostConstruct
//        public void postConstruct() {
//            for (AEMese mese : AEMese.values()) {
//                mese.setText(text);
//            }
//        }
//
//    }


label.getElement().getStyle().set("color", "blue");
span.getElement().getStyle().set("font-weight", "bold");


     * Deve essere sovrascritto <br>
     * Deve essere sovrascritto, invocando PRIMA il metodo della superclasse <br>
     * Può essere sovrascritto, invocando PRIMA il metodo della superclasse <br>

 * Per omogeneità è meglio usare 'static final' (piuttosto che l'equivalente 'final static') <br>


    /**
     * Costruttore base senza parametri <br>
     * Non usato. Serve solo per 'coprire' un piccolo bug di Idea <br>
     * Se manca, manda in rosso i parametri del costruttore usato <br>
     */
    public AnnoDialog() {

    } // end of SpringBoot constructor

    /**
     * Costruttore con parametri <br>
     * L' istanza viene costruita con appContext.getBean(xxx.class, ...parameters) <br>
     */
    public ATopLayout(WrapButtons wrapButtons) {

    } // end of SpringBoot constructor

#long to int
Math.toIntExact(min);

#Long to int
min.intValue();

    /**
     * La injection viene fatta da SpringBoot SOLO DOPO il metodo init() del costruttore <br>
     * Si usa quindi un metodo @PostConstruct per avere disponibili tutte le (eventuali) istanze @Autowired <br>
     * Questo metodo viene chiamato subito dopo che il framework ha terminato l' init() implicito <br>
     * del costruttore e PRIMA di qualsiasi altro metodo <br>
     * <p>
     * Ci possono essere diversi metodi con @PostConstruct e firme diverse e funzionano tutti, <br>
     * ma l' ordine con cui vengono chiamati (nella stessa classe) NON è garantito <br>
     */
    @PostConstruct
    protected void postConstruct() {
        this.init();
    }


Div content = new Div();
content.getElement().setProperty("innerHTML", "<p>Hello World</p></br><span>Some text after a break</span>");


        if (WamEntity.class.isAssignableFrom(entityClass)||Milite.class.isAssignableFrom(entityClass)) {
            codice
        }// end of if cycle


		grid.addColumn(User::getEmail).setWidth("270px").setHeader("Email").setFlexGrow(5);
		grid.addColumn(u -> u.getFirstName() + " " + u.getLastName()).setHeader("Name").setWidth("200px").setFlexGrow(5);
		grid.addColumn(User::getRole).setHeader("Role").setWidth("150px");

Notification.show("Alcuni campi non sono adeguati", 3000, Notification.Position.MIDDLE);

        //--Controlla che il parametro in ingresso sia della classe prevista
        if (AEntity.class.isAssignableFrom(genericClazz)) {
        }
